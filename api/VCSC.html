<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Value-Compressed Sparse Column (VCSC) Class Reference &mdash; PyVSparse 0.4.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=6c02275b"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Example Usage" href="../examples.html" />
    <link rel="prev" title="Index-and Value-Compressed Sparse Column (IVCSC) Class Reference" href="IVCSC.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            PyVSparse
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../PyVSparse.html">PyVSparse</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../api.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="IVCSC.html">Index-and Value-Compressed Sparse Column (IVCSC) Class Reference</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Value-Compressed Sparse Column (VCSC) Class Reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Example Usage</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PyVSparse</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../api.html">API Reference</a></li>
      <li class="breadcrumb-item active">Value-Compressed Sparse Column (VCSC) Class Reference</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/api/VCSC.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="value-compressed-sparse-column-vcsc-class-reference">
<h1>Value-Compressed Sparse Column (VCSC) Class Reference<a class="headerlink" href="#value-compressed-sparse-column-vcsc-class-reference" title="Link to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="PyVSparse.VCSC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">PyVSparse.</span></span><span class="sig-name descname"><span class="pre">VCSC</span></span><a class="reference internal" href="../_modules/PyVSparse/vcsc.html#VCSC"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyVSparse.VCSC" title="Link to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="PyVSparse.VCSC._COOconstruct">
<span class="sig-name descname"><span class="pre">_COOconstruct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">moduleName</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spmat</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyVSparse/vcsc.html#VCSC._COOconstruct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyVSparse.VCSC._COOconstruct" title="Link to this definition"></a></dt>
<dd><p>Private helper function to construct a VCSC matrix from a scipy.sparse COO matrix.
In C++, the constructor expects std::tuple&lt;indexT, indexT, T&gt; for each non-zero element.</p>
<p>C++ declaration:
template &lt;typename T2, typename indexT2&gt;
VCSC(std::vector&lt;std::tuple&lt;indexT2, indexT2, T2&gt;&gt;&amp; entries, uint64_t num_rows, uint32_t num_cols, uint32_t nnz);</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>moduleName</strong> (<em>str</em>) – The name of the module to construct the VCSC matrix from</p></li>
<li><p><strong>spmat</strong> (<em>sp.sparse.coo_matrix</em>) – The input matrix</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyVSparse.VCSC._CSconstruct">
<span class="sig-name descname"><span class="pre">_CSconstruct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">moduleName</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spmat</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyVSparse/vcsc.html#VCSC._CSconstruct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyVSparse.VCSC._CSconstruct" title="Link to this definition"></a></dt>
<dd><p>Private helper function to construct a VCSC matrix from a scipy.sparse CSC or CSR matrix.
This uses the Eigen::SparseMatrix&lt;T&gt; constructor in C++. Pybind11 handles the conversion.</p>
<p>A pure Python implementation of a CSR/C matrix could be used to make a VCSC matrix, but
that is not implemented at this time. The C++ backend <em>should</em> support it though.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>moduleName</strong> (<em>str</em>) – The name of the module to construct the VCSC matrix from</p></li>
<li><p><strong>spmat</strong> (<em>Union</em><em>[</em><em>sp.sparse.csc_matrix</em><em>, </em><em>sp.sparse.csr_matrix</em><em>]</em>) – The input matrix</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyVSparse.VCSC.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyVSparse/vcsc.html#VCSC.__eq__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyVSparse.VCSC.__eq__" title="Link to this definition"></a></dt>
<dd><p>Compares the matrix to another VCSC matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#PyVSparse.VCSC" title="PyVSparse.VCSC"><em>VCSC</em></a>) – The matrix to compare to</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the matrices are equal, False otherwise</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyVSparse.VCSC.__getitem__">
<span class="sig-name descname"><span class="pre">__getitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyVSparse/vcsc.html#VCSC.__getitem__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyVSparse.VCSC.__getitem__" title="Link to this definition"></a></dt>
<dd><p>Random access operator for VCSC.</p>
<p>As of right now, this only supports random access of a single element.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>key</strong> (<em>int</em>) – The index of the element to access</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the element at the index</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>any</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyVSparse.VCSC.__imul__">
<span class="sig-name descname"><span class="pre">__imul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyVSparse/vcsc.html#VCSC.__imul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyVSparse.VCSC.__imul__" title="Link to this definition"></a></dt>
<dd><p>Inplace multiplication of the matrix by a scalar</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> (<em>Union</em><em>[</em><em>int</em><em>, </em><em>float</em><em>]</em>) – The value or object to multiply the matrix by</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The matrix multiplied by the input</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#PyVSparse.VCSC" title="PyVSparse.VCSC">VCSC</a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>TypeError</strong> – If the input is not a scalar or numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyVSparse.VCSC.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spmat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indexType</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">numpy.uint32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'col'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyVSparse/vcsc.html#VCSC.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyVSparse.VCSC.__init__" title="Link to this definition"></a></dt>
<dd><p>Value-Compressed Sparse Column is a read-only sparse matrix format for redundant data without compromising speed.
See README.md for more information.</p>
<p>While the name is indicitive of the storage order, the matrix can be stored in either column-major or row-major order.</p>
<p>This class can be constructed from a few different options:
1.) scipy.sparse.csc_matrix
2.) scipy.sparse.csr_matrix
3.) scipy.sparse.coo_matrix
4.) PyVSparse.VCSC
5.) A .vcsc file (written by VCSC.write() or a C++ program that uses VCSC.write()).</p>
<p>The user can specify the index type of the matrix. The default is np.uint32. The python version is
limited to unsigned integers, becasue there is no advantage to using signed integers. The choice of
index type should not affect performance, correctness, or what features are available. The only difference
SHOULD be the memory consumption of the matrix, unless you are attempting to store more than the integer
limit of the index type. i.e. storing 256 rows/cols with a np.uint8 index type.</p>
<p>The user can also specify the storage order of the matrix. The default is “Col” for column-major order.</p>
<dl>
<dt>Note: Becasue of how indices are stored in VCSC, cache misses are more commmon. For a very redundant matrix,</dt><dd><p>the performance of VCSC will be just as fast, in some cases faster, than a CSC matrix because caching is possible.
However, this is based on naive implementation of matrix operations, so matrix multiplication will be faster for
SciPy matrices that use BLAS.</p>
<p>VCSC is faster than IVCSC becasue indices are byte-aligned, but does not offer the same level of compression.</p>
<p>Coefficient-wise operations may be much faster because fewer are stored.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>spmat</strong> (<em>Union</em><em>[</em><em>sp.sparse.csc_matrix</em><em>, </em><em>sp.sparse.csr_matrix</em><em>, </em><em>sp.sparse.coo_matrix</em><em>, </em><a class="reference internal" href="#PyVSparse.VCSC" title="PyVSparse.VCSC"><em>PyVSparse.VCSC</em></a><em>, </em><em>str</em><em>]</em>) – The input matrix or .vcsc filename</p></li>
<li><p><strong>indexType</strong> (<em>np.dtype</em>) – The index type of the matrix. The default is np.uint32</p></li>
<li><p><strong>order</strong> (<em>str</em>) – The storage order of the matrix. The default is “Col” for column-major order. “Row” can also be specified for row-major order. Capitalization does not matter.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyVSparse.VCSC.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyVSparse/vcsc.html#VCSC.__mul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyVSparse.VCSC.__mul__" title="Link to this definition"></a></dt>
<dd><p>Multiplication of the matrix by a:
- scalar
- dense numpy matrix or vector</p>
<p>If the input is a scalar, then the matrix returned will be a VCSC matrix.
Else, the matrix returned will be a dense numpy matrix or vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> (<em>Union</em><em>[</em><em>int</em><em>, </em><em>float</em><em>, </em><em>np.ndarray</em><em>]</em>) – The value or object to multiply the matrix by</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The matrix multiplied by the input</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>union[<a class="reference internal" href="#PyVSparse.VCSC" title="PyVSparse.VCSC">VCSC</a>, np.ndarray]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>TypeError</strong> – If the input is not a scalar or numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyVSparse.VCSC.__ne__">
<span class="sig-name descname"><span class="pre">__ne__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyVSparse/vcsc.html#VCSC.__ne__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyVSparse.VCSC.__ne__" title="Link to this definition"></a></dt>
<dd><p>Compares the matrix to another VCSC matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#PyVSparse.VCSC" title="PyVSparse.VCSC"><em>VCSC</em></a>) – The matrix to compare to</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the matrices are not equal, False otherwise</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyVSparse.VCSC.append">
<span class="sig-name descname"><span class="pre">append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyVSparse/vcsc.html#VCSC.append"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyVSparse.VCSC.append" title="Link to this definition"></a></dt>
<dd><p>Appends a matrix to the current matrix</p>
<p>The appended matrix must be of the same type or a scipy.sparse.csc_matrix/csr_matrix
depending on the storage order of the current matrix. For a column-major matrix,
the appended matrix will be appended to the end of the columns. For a row-major matrix,
the appended matrix will be appended to the end of the rows.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>matrix</strong> (<em>Union</em><em>[</em><a class="reference internal" href="#PyVSparse.VCSC" title="PyVSparse.VCSC"><em>VCSC</em></a><em>, </em><em>sp.sparse.csc_matrix</em><em>, </em><em>sp.sparse.csr_matrix</em><em>]</em>) – The matrix to append</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>TypeError</strong> – If the input matrix is not a supported type of matrix</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyVSparse.VCSC.byteSize">
<span class="sig-name descname"><span class="pre">byteSize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyVSparse/vcsc.html#VCSC.byteSize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyVSparse.VCSC.byteSize" title="Link to this definition"></a></dt>
<dd><p>Returns the memory consumption of the matrix in bytes</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.uint64</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyVSparse.VCSC.fromVCSC">
<span class="sig-name descname"><span class="pre">fromVCSC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spmat</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyVSparse/vcsc.html#VCSC.fromVCSC"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyVSparse.VCSC.fromVCSC" title="Link to this definition"></a></dt>
<dd><p>Copy constructor for VCSC</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>spmat</strong> (<a class="reference internal" href="#PyVSparse.VCSC" title="PyVSparse.VCSC"><em>VCSC</em></a>) – The input VCSC matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyVSparse.VCSC.getCounts">
<span class="sig-name descname"><span class="pre">getCounts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">outerIndex</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyVSparse/vcsc.html#VCSC.getCounts"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyVSparse.VCSC.getCounts" title="Link to this definition"></a></dt>
<dd><p>Returns the number of non-zero elements in a column or row depending on storage order.</p>
<dl class="simple">
<dt>For example, if the matrix is:</dt><dd><p>[1]
[1]
[2]</p>
</dd>
</dl>
<p>Then the list [1, 2] will be returned</p>
<dl class="simple">
<dt>Note: Whether the counts are from a column or row depends on order of the matrix.</dt><dd><p>A matrix stored in column-major order will return the counts of a column.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>outerIndex</strong> (<em>int</em>) – The index of the column or row to get the counts of</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list containing the counts of the column or row</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list[Union[np.uint8, np.uint16, np.uint32, np.uint64]]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>IndexError</strong> – If the provided index is out of range</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyVSparse.VCSC.getIndices">
<span class="sig-name descname"><span class="pre">getIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">outerIndex</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyVSparse/vcsc.html#VCSC.getIndices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyVSparse.VCSC.getIndices" title="Link to this definition"></a></dt>
<dd><p>Returns the indices of a column or row depending on storage order.</p>
<dl class="simple">
<dt>Note: Whether the indices are from a column or row depends on order of the matrix.</dt><dd><p>A matrix stored in column-major order will return the indices of a column.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>outerIndex</strong> (<em>int</em>) – The index of the column or row to get the indices of</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list containing the indices of the column or row</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>IndexError</strong> – If the provided index is out of range</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyVSparse.VCSC.getNumIndices">
<span class="sig-name descname"><span class="pre">getNumIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">outerIndex</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyVSparse/vcsc.html#VCSC.getNumIndices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyVSparse.VCSC.getNumIndices" title="Link to this definition"></a></dt>
<dd><p>Returns the number of unique values in a column or row depending on storage order.</p>
<dl class="simple">
<dt>Note: Whether the number of indices are from a column or row depends on order of the matrix.</dt><dd><p>A matrix stored in column-major order will return the number of indices of a column.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>outerIndex</strong> (<em>int</em>) – The index of the column or row to get the number of indices of</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list containing the number of indices of each column or row</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>IndexError</strong> – If the provided index is out of range</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyVSparse.VCSC.getValues">
<span class="sig-name descname"><span class="pre">getValues</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">outerIndex</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyVSparse/vcsc.html#VCSC.getValues"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyVSparse.VCSC.getValues" title="Link to this definition"></a></dt>
<dd><p>Returns the unique values of a column or row depending on storage order.</p>
<dl class="simple">
<dt>Note: Whether the values are from a column or row depends on order of the matrix.</dt><dd><p>A matrix stored in column-major order will return the values of a column.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>outerIndex</strong> (<em>int</em>) – The index of the column or row to get the values of</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list containing the unique values of the column or row</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>IndexError</strong> – If the provided index is out of range</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyVSparse.VCSC.max">
<span class="sig-name descname"><span class="pre">max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyVSparse/vcsc.html#VCSC.max"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyVSparse.VCSC.max" title="Link to this definition"></a></dt>
<dd><p>On axis=None, returns the maximum of all elements in the matrix</p>
<p>If axis=0, returns the maximum of each column</p>
<p>If axis=1, returns the maximum of each row</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>axis</strong> (<em>int</em>) – The axis to find the maximum along. The default is None, which finds the maximum of all elements in the matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The maximum of the matrix or the maximum of each row/column</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.int64, np.double, np.ndarray]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyVSparse.VCSC.min">
<span class="sig-name descname"><span class="pre">min</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyVSparse/vcsc.html#VCSC.min"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyVSparse.VCSC.min" title="Link to this definition"></a></dt>
<dd><p>On axis=None, returns the minimum of all <em>nonzero</em> elements in the matrix</p>
<p>If axis=0, returns the <em>nonzero</em> minimum of each column</p>
<p>If axis=1, returns the <em>nonzero</em>  minimum of each row</p>
<dl>
<dt>Note: because of the way the matrix is stored,</dt><dd><p>minimums that are zero are very expensive to compute.</p>
<p>There are a few exceptions:
- If a row/column is all zeros, then the minimum will be zero.
- if axis=None, then the minimum will be zero if nnz &lt; rows * cols</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>axis</strong> (<em>int</em>) – The axis to find the minimum along. The default is None, which finds the minimum of all <em>nonzero</em> elements in the matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The minimum of the matrix or the minimum of each row/column</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.int64, np.double, np.ndarray]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyVSparse.VCSC.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyVSparse/vcsc.html#VCSC.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyVSparse.VCSC.norm" title="Link to this definition"></a></dt>
<dd><p>Returns the Frobenius norm of the matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The Frobenius norm of the matrix</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.double</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyVSparse.VCSC.read">
<span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyVSparse/vcsc.html#VCSC.read"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyVSparse.VCSC.read" title="Link to this definition"></a></dt>
<dd><p>Function to read a VCSC formatted matrix from a file.
This function should automatically determine the template type of the matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>filename</strong> (<em>str</em>) – The name of the file to read from</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyVSparse.VCSC.shape">
<span class="sig-name descname"><span class="pre">shape</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyVSparse/vcsc.html#VCSC.shape"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyVSparse.VCSC.shape" title="Link to this definition"></a></dt>
<dd><p>Returns the shape of the matrix as a tuple (rows, cols)</p>
<p>:return The shape of the matrix
:rtype: Tuple[np.uint32, np.uint32]</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple[numpy.uint32, numpy.uint32]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyVSparse.VCSC.slice">
<span class="sig-name descname"><span class="pre">slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyVSparse/vcsc.html#VCSC.slice"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyVSparse.VCSC.slice" title="Link to this definition"></a></dt>
<dd><p>Returns a slice of the matrix.</p>
<p>Currently, only slicing by storage order is supported. For example, if the matrix is stored in column-major order,
Then the returned matrix will be a slice of the columns.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start</strong> (<em>int</em>) – The start index of the slice</p></li>
<li><p><strong>end</strong> (<em>int</em>) – The end index of the slice</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The slice of the matrix</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#PyVSparse.VCSC" title="PyVSparse.VCSC">VCSC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyVSparse.VCSC.sum">
<span class="sig-name descname"><span class="pre">sum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyVSparse/vcsc.html#VCSC.sum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyVSparse.VCSC.sum" title="Link to this definition"></a></dt>
<dd><p>On axis=None, returns the sum of all elements in the matrix</p>
<p>If axis=0, returns the sum of each column</p>
<p>If axis=1, returns the sum of each row</p>
<p>Note: Sum is either int64 or a double</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>axis</strong> (<em>int</em>) – The axis to sum along. The default is None, which sums all elements in the matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The sum of the matrix or the sum of each row/column</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.int64, np.double, np.ndarray]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the axis is not 0, 1, or None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyVSparse.VCSC.tocsc">
<span class="sig-name descname"><span class="pre">tocsc</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyVSparse/vcsc.html#VCSC.tocsc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyVSparse.VCSC.tocsc" title="Link to this definition"></a></dt>
<dd><p>Converts the matrix to a scipy.sparse.csc_matrix</p>
<dl class="simple">
<dt>Note: This is a copy. This does not destroy the original matrix.</dt><dd><p>If the storage order of the VCSC matrix is in row-major, then
then a csr_matrix will be created and converted to a csc_matrix.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The matrix in csc format</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>sp.sparse.csc_matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyVSparse.VCSC.tocsr">
<span class="sig-name descname"><span class="pre">tocsr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyVSparse/vcsc.html#VCSC.tocsr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyVSparse.VCSC.tocsr" title="Link to this definition"></a></dt>
<dd><p>Converts the matrix to a scipy.sparse.csr_matrix</p>
<dl class="simple">
<dt>Note: This is a copy. This does not destroy the original matrix.</dt><dd><p>If the storage order of the VCSC matrix is in column-major, then
then a csc_matrix will be created and converted to a csr_matrix.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The matrix in scipy.sparse.csr_matrix format</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>sp.sparse.csr_matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyVSparse.VCSC.trace">
<span class="sig-name descname"><span class="pre">trace</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyVSparse/vcsc.html#VCSC.trace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyVSparse.VCSC.trace" title="Link to this definition"></a></dt>
<dd><p>Returns the sum of all elements along the diagonal.</p>
<p>Throws ValueError if matrix is not square.</p>
<p>Note: Sum is either int64 or a double.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The sum of the diagonal</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Union[np.int64, np.double]</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the matrix is not square</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyVSparse.VCSC.transpose">
<span class="sig-name descname"><span class="pre">transpose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyVSparse/vcsc.html#VCSC.transpose"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyVSparse.VCSC.transpose" title="Link to this definition"></a></dt>
<dd><p>Transposes the matrix.</p>
<dl>
<dt>Note: This is a very slow operation. It is recommended to use the transpose() function from another matrix format instead.</dt><dd><p>Nothing is returned if the operation is in place.</p>
<p>Memory usage will change after this operation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>inplace</strong> (<em>bool</em>) – Whether to transpose the matrix in place. The default is True</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transposed VCSC matrix</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#PyVSparse.VCSC" title="PyVSparse.VCSC">VCSC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyVSparse.VCSC.vectorLength">
<span class="sig-name descname"><span class="pre">vectorLength</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyVSparse/vcsc.html#VCSC.vectorLength"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyVSparse.VCSC.vectorLength" title="Link to this definition"></a></dt>
<dd><p>Returns the euclidean length of the vector</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>vector</strong> (<em>int</em>) – The index of the vector to find the euclidean length of</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The euclidean length of the vector</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.double</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>IndexError</strong> – If the vector index is out of range</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyVSparse.VCSC.write">
<span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyVSparse/vcsc.html#VCSC.write"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyVSparse.VCSC.write" title="Link to this definition"></a></dt>
<dd><p>Writes the matrix to a file. If the file name doesn’t include .vcsc, it will be appended.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>filename</strong> (<em>str</em>) – The name of the file to write to</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="IVCSC.html" class="btn btn-neutral float-left" title="Index-and Value-Compressed Sparse Column (IVCSC) Class Reference" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../examples.html" class="btn btn-neutral float-right" title="Example Usage" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Seth Wolfgang.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>