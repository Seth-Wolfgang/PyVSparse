<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PyVSparse &mdash; PyVSparse 0.4.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=6c02275b"></script>
        <script src="_static/doctools.js?v=9a2dae69"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="API Reference" href="api.html" />
    <link rel="prev" title="Welcome to PyVSparse’s documentation!" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            PyVSparse
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">PyVSparse</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Example Usage</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PyVSparse</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">PyVSparse</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/PyVSparse.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="pyvsparse">
<h1>PyVSparse<a class="headerlink" href="#pyvsparse" title="Link to this heading"></a></h1>
<p>PyVSparse is a Python wrapper for the IVSparse library. The C++ documentation can be found <a class="reference external" href="https://seth-wolfgang.github.io/IVSparse/">here</a>
and the source is on <a class="reference external" href="https://github.com/Seth-Wolfgang/IVSparse">github</a>.</p>
<p>Much of this page is adapted from the IVSparse documentation.</p>
<section id="what-is-pyvsparse">
<h2>What is PyVSparse?<a class="headerlink" href="#what-is-pyvsparse" title="Link to this heading"></a></h2>
<p>IVSparse is a library with two new ways to store sparse data much like compressed sparse column (CSC) or coordinate format (COO).
These two new compression formats are called Value Compressed Sparse Column (VCSC) and Index and Value Compressed Sparse Column (IVCSC).
These two formats are meant to take advantage of highly redundant data and compress it by value or by index and value respectively,
without losing too much traversal speed.</p>
<p>However, the library is written in C++ and is not easily accessible to Python users. PyVSparse is a Python wrapper for the IVSparse library.
Many applications in bioinfomatics and machine learning use python because of the ease of use and the large number of libraries available.
PyVSparse allows these applications to take advantage of the speed and compression of the IVSparse library.</p>
</section>
<section id="how-does-vcsc-and-ivcsc-work">
<h2>How does VCSC and IVCSC work?<a class="headerlink" href="#how-does-vcsc-and-ivcsc-work" title="Link to this heading"></a></h2>
<p>There are a few different ways in which IVSparse compresses data.
The first is redundancy, by only storing unique values in a column much data can be saved especially for larger sized values like doubles.
The second is Positive Delta Encoding, which is a process which we apply to the indices of a unique value in a column which encodes the distance between each index.
The third way is through bytepacking, which is when we cast each unqiue value’s indices to the smallest data type that doesn’t lose precision.
VCSC uses the value compression technique and IVCSC uses the value compression as well as postive delta encoding and bytepacking to compress indices.</p>
<section id="redundancy">
<h3>Redundancy<a class="headerlink" href="#redundancy" title="Link to this heading"></a></h3>
<p>It’s easy to see how redundancy can be taken advantage of when looking at CSC format.
In this format each value and index must be listed once no matter the data, with a set of pointers being used to delimit columns.
However in VCSC and IVCSC if a column has only a single value, it’s only stored once and then all of the indices that value is located will be associated with it.
This means that in the simplest case of a vector of 50 ones, CSC needs to store 100 values where as VCSC and IVCSC needs only to store 51,
the 1 (value) and all the indices where 1 appears.</p>
<p>Therefore in datasets that are highly redundant we mananges to not explicitly store a lot of values, resulting in good compression ratios for this data.
It is worth being said however that data that is almost completely unique however will cause this pendulum to swing in the other direction,
causing worse compression in the worst case scenario since VCSC and IVCSC has more overhead to organize the data than CSC.</p>
</section>
<section id="positive-delta-endoding">
<h3>Positive-Delta Endoding<a class="headerlink" href="#positive-delta-endoding" title="Link to this heading"></a></h3>
<p>We use this to take the indices inside of a unique value and encode the distance between them.
While this doesn’t cause us to store any less values, it can take larger values and make them smaller.
Such as for a 10,000 x 10,000 matrix near the end of a column the indices could be […, 9,973, 9,979, 9,981, 9,991],
each of these values requires a 16 byte data type to store whereas if we positive delta encode them into […, 3, 6, 2, 10] the values
get much smaller and could potentially fit into a smaller data type.</p>
<p>It should also be noted that this does make the data harder to traverse making it a tradeoff that isn’t always worth it and will make data traversal slower,
espeically if the data doesn’t lend itself to the advantages of positive delta encoding by being incredibly sparse or with distances very far apart.</p>
</section>
<section id="byte-packing">
<h3>Byte-Packing<a class="headerlink" href="#byte-packing" title="Link to this heading"></a></h3>
<p>This is a process that takes all of the indices of a unique value, finds the maximum value after positive delta encoding,
and casts the indices to the smallest data type that doesn’t lose precision.
Such as if a user has a IVCSC matrix with indices stored in unsigned long long int yet no number exceedes 255.
In this situation each unique value’s fiber’s indices would most likely be cast to a unsigned short int saving 7 bytes per index.
This is great for isolating outlier data from enforcing a large data type and in combination with positive delta encoding can result in even very large matrices being
heavily conmpressed with very little wasted space in the indices.</p>
<p>As a side note, this as well makes the data somewhat more difficult to work with causing some degree of
complication and slowdowns for data traversal but is often very much worth the savings.</p>
</section>
</section>
<section id="compression-formats-explained">
<h2>Compression Formats Explained<a class="headerlink" href="#compression-formats-explained" title="Link to this heading"></a></h2>
<p>There are currently 3 compression formats supported by IVSparse which are presented in order of compression below.</p>
<section id="compressed-sparse-column-csc">
<h3>Compressed Sparse Column (CSC):<a class="headerlink" href="#compressed-sparse-column-csc" title="Link to this heading"></a></h3>
<p>This is simply just the CSC matrix format. This is helpful for transitioning between deeper compression levels and back to a more workable format as many times CSC is far faster for certain algorithms. This also helps increase interoperability with other libraries and within IVSparse. CSC also works better for matrices with mostly unique values and has the fastest traversal speeds.</p>
</section>
<section id="value-compressed-sparse-column-vcsc">
<h3>Value Compressed Sparse Column (VCSC):<a class="headerlink" href="#value-compressed-sparse-column-vcsc" title="Link to this heading"></a></h3>
<p>VCSC is a derivative of CSC meant to implement value compression on redundant values. This is done by storing only the unique values of each column/row and the number of occurances of each value. This means there are three arrays per outer dimension, the values, the counts, and the inner indices of the values. This format has fast scalar operations and is somewhat fast to traverse due to the counts array. This format also needs to have a fair amount of redundant values to benefit over CSC and is not recommended for data that is mostly unique.</p>
</section>
<section id="index-and-value-compressed-sparse-column-ivcsc">
<h3>Index and Value Compressed Sparse Column (IVCSC):<a class="headerlink" href="#index-and-value-compressed-sparse-column-ivcsc" title="Link to this heading"></a></h3>
<p>IVCSC is the format meant to focus primarily on compressing. This is done by compressing both indices as well as values. Firstly, IVCSC stores each column in its own contiguous block of memory. Inside each column’s memory is a series of runs. Runs are associated with each unique value in the column. Runs are sorted by unique value in ascending order. The format of a run is the value, the width of the follwing indices, the indices associated with the unique value positive delta encoded, and finally a delimiter to signify the end of a run. IVCSC uses both index and value compression to achieve the highest compression ratio. The values are compressed by only storing the unique values of each column and the indices for each individual run are positive delta encoded and then bytepacked into the smallest usable size. This format is the slowest to traverse but has the highest compression ratio, that isn’t to say one can’t do operations with IVCSC they just won’t be quite as fast as a CSC matrix.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Welcome to PyVSparse’s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="api.html" class="btn btn-neutral float-right" title="API Reference" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Seth Wolfgang.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>